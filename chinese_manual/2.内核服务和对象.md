## 第二章 内核服务和对象

微内核提供有限数量的服务原语； 更复杂的应用程序可以在这些原语的基础上进行实现。通过这种方式，可以在不增加特权模式下的代码和复杂性的情况下扩展系统的功能，同时支持针对不同应用领域的潜在大量服务。

**seL4提供的基础服务：**

**Thread** 是支持运行软件的CPU执行抽象。

**Address spaces** 是虚拟内存空间，每个空间包含一个应用程序。 应用程序只能够访问其地址空间中的内存。

**Inter-process communication (IPC)** 允许Thread通过endpoint进行通信（消息传递）。

**Notifications** 提供了一种类似于二值信号量的非阻塞信号机制。

**Device primitives（设备原语）** 允许将设备驱动程序实现为非特权应用程序。 内核通过IPC消息导出硬件设备中断；

**Capability spaces（功能空间）** 存储对内核服务的功能（即访问权限）以及它们的记录信息。

本章概述了这些服务，描述了内核对象如何被用户空间应用程序访问，并描述了如何创建新对象。

### 2.1 基于访问控制的Capability（功能）

seL4微内核提供了一个基于 Capability 的访问控制模型。访问控制管理所有内核服务；为了执行操作，应用程序必须调用其拥有的对所请求的服务具有直接访问权限的功能。由此，该系统可以被配置成将软件组件彼此隔离，并且还可以通过选择性地授予特定通信能力来实现组件之间的授权的、受控的通信。这使得软件组件隔离具有高度的保证，因为只有那些 Capability 拥有明确授权的操作才被允许。

Capability 是一个不可伪造的标记。它引用了一个特定的内核对象（如Thread Control Block 线程控制块），并携带了控制能够调用何种方法的访问权限。从概念上讲，Capability 驻留在应用程序的 Capability Space（功能空间）中；该空间中的地址指的是可以包含或不包含能力的slot（锁、槽、位置、片段）。 应用程序可以引用请求内核服务的能力，例如使用保持该能力的slot的地址。 这意味着seL4功能模型是隔离（或分区）功能系统的实例，其中功能由内核管理。

Capability Space 被实现为内核管理的功能节点（CNodes）的有向图。CNode是一个slot表，其中每个slot可能包含进一步的CNode功能。Capability Space中的能力的地址是形成到目的地slot的路径的CNode内的slot的索引的级联；我们在第3章中详细讨论了CNode对象。

Capabilities （我的理解是--功能组）可以在 Capability Space内复制和移动，也可以通过IPC发送。 这允许创建具有特定访问权限的应用程序，将权限委托给另一个应用程序，并将权限传递给新创建的（或选定的）内核服务的应用程序。 此外，可以对Capabilities进行修改，以创建一个派生Capabilities，该派生Capabilities具有原始Capabilities的一个权限子集（决不具有更多权限）。新形成的能力可用于部分授权。

Capabilities 可以被撤销，从而撤销权限。撤销操作会递归地删除从被撤销的原始 Capabilities 派生的任何功能。 Capabilities 通过系统的传播是由一个基于“接受-授权”的模型控制的[EKE08,Boy09]。

### 2.2 系统调用

